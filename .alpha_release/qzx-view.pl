#!/usr/bin/env perl

use strict;
use warnings;
use File::Basename;
use Getopt::Long;
#use YAML;
use YAML::XS 'Load';
use Data::Dumper;
use Term::ANSIColor  qw(:constants);


my ($opt_list, $opt_view_file, $opt_debug, $opt_nocolor, $opt_help, $opt_head, $opt_grep,
	$opt_tabs, $opt_shownum, $opt_yaml, $opt_trace );


my $opt_get = GetOptions(
	'v|view=s'  => \$opt_view_file,
	'j|head=i'  => \$opt_head,
	'g|grep=s'  => \$opt_grep,
	'y|yaml'    => \$opt_yaml,
	's|spaces=i'  => \$opt_tabs,
	't|trace'   => \$opt_trace,
	'shownum'   => \$opt_shownum,
	'l|list:s'    => \$opt_list,
	'd|debug'	=> \$opt_debug,
	'h|help'    => \$opt_help,
	'n|nocolor'	=> \$opt_nocolor
);


my $filename = shift(@ARGV);
unless ($filename) {
	help();
	exit;
}

help() if ($opt_help);

# Check unzip version, warn if a different string is found (but possibly OK)
testzip();

# Check input file exists
if (!-e "$filename") {
	crash("File \"$filename\" was not found.",'Missing input file',  1000);
}

# Get ZIP file content, stripping the ID
my ($archive_id, $file_array_ref) = parse_zip_files("$filename");

info("Archive UUID: $archive_id");
get_file_from_zip('VERSION');
check_strings("VERSION", "QIIME 2", "archive: 2","framework: 20");

if (defined($opt_list)) {
	if ($opt_list) {
		info("Listing files matching: '$opt_list'");
	} else {
		info("Listing files: <all files>");
	}


	foreach my $file (@{$file_array_ref}) {
		print "$file\n" if ($file =~/$opt_list/);
	}
}

if ($opt_view_file) {
	info("View files matching: \"$opt_view_file\"");
	foreach my $file (@{$file_array_ref}) {
		if ($file =~/$opt_view_file/) {
			 
			print BOLD unless ($opt_nocolor);
			print "# VIEWING:\t$file\n", RESET;
			my $raw_lines = get_file_from_zip($file);
			my @lines = split /\n/, $raw_lines;
			my $c = 0;

			if (defined($opt_yaml)) {
				
				my $yaml_hash_ref = Load($raw_lines);
				#print Dumper $yaml_hash_ref;	
			} else {
				foreach my $line (@lines) {
					$c++;
					
					if (!defined($opt_head) or $c <= $opt_head) {
						my $SPACE_SIZE = 0;
						next if (defined($opt_grep) and $line!~/$opt_grep/);
						if (defined($opt_tabs)) {
							if ($line=~/^([\s]+)\S/) {
								$SPACE_SIZE = length($1);
								next if ($SPACE_SIZE > $opt_tabs);	
							}
							
						} 
						print BLUE unless ($opt_nocolor);
						my $s = length($line);
						print "[$c:$s]\t",RESET if ($opt_shownum);
						print RESET, "$line\n";
					} 
				}
				print "\n";
			}
		}
	}
}


my %inputsof=();
my %generators=();

my %typeof=();
my %formatof=();
my %actiontypeof=();
my %actionof;
my %outputnameof;

if ($opt_trace) {
	my $start_yaml = get_file_from_zip('provenance/action/action.yaml');
	my $action = Load($start_yaml);



	# scan YAML
	foreach my $file (@{$file_array_ref}) {

		next if ($file!~/^provenance\/artifacts\/(.*).(action.action|metadata)\.yaml$/);
		
		 
		
		my $UUID = $1;
		my $yaml_raw_text = get_file_from_zip($file);
		my $yaml = Load ($yaml_raw_text);
		if ($2 eq 'metadata') {
			### METADATA
			#print BOLD BLUE  "\n-----    TYPE: METADATA ($1 -> $2)\n", RESET;#TODO	 
			my $type =  $yaml->{'type'};
			my $uuid =  $yaml->{'uuid'};
			my $form =  $yaml->{'format'};

			warning('Unexpected', "File's UUID ($UUID) not matching metadata ($uuid)")
				unless ($UUID eq $uuid);

			#info("UUID:$uuid =>  TYPE:$type");
			 
			#push(@{$typeof{'dd'}}, $type."($uuid)");
			$typeof{$uuid} = $type;
			$formatof{$uuid} = $form;


		} else {
			### ACTION
			#print BOLD BLUE  "\n@@@@@    TYPE: ACTION  ($1 -> $2)\n", RESET;#TODO	 
			
			my $action_type = $yaml->{action}->{type};

			

			my $action = '';
			my $outputname = ''; 
			$actiontypeof{$1} = $action_type;
			$action = $yaml->{action}->{action} if (defined $yaml->{action}->{action});
			$actionof{$1} = $action;
			$outputname = $yaml->{action}->{'output-name'} if (defined $yaml->{action}->{'output-name'});
			$outputnameof{$1} = $outputname;

			foreach my $input (@{$yaml->{'action'}->{'inputs'}}) {
				 
				foreach my $key (keys %{$input}){
					
					 $typeof{${$input}{$key}} = $key;
					 if (defined ${$input}{$key}) {
					 	push(@{$inputsof{$UUID}}, ${$input}{$key});
					 }
					 #print " #\n # $UUID ${$input}{$key}\n #\n";
					 #push(@{$inputsof{$UUID}}, ${$input}{$key});
					 #info("Input of $UUID: ${$input}{$key}");
					 #print Dumper @{$inputsof{$UUID}};
					 #print "\n", RESET;
				}
			}
		}
		
	}

 
	

	#info("This file has been generated by:");
	foreach my $input_hash (@{$action->{'action'}->{'inputs'}}) {
		my $input_count;
		foreach my $input_key (keys %{$input_hash}) {
			$input_count++;
			my $uuid = $$input_hash{$input_key};

			#print "\t$input_count:\t$input_key [$uuid]\n";
			push(@{$generators{$archive_id}}, $uuid);
			$typeof{$uuid} = $input_key;
			my $trace = 0;

		}

		my $generator = $archive_id;
		#print BOLD "\t$generator\n", RESET;
		print "\tType:\t",$typeof{$generator}, "\n" if (defined $typeof{$generator});
		print "\tAction:\t",$actionof{$generator},"\n" if (defined $actionof{$generator});
		print "\tFormat:\t",$formatof{$generator},"\n" if (defined $formatof{$generator});

		my $c = 0;
		$generator = '';


		foreach my $g (@{$generators{$archive_id}}) {
			$c++;
			print "[$c]\t$g\t$typeof{$g}\t\n";
			$generator = $g;
		}
		print "\n";

		if ($c == 1) {
			my $finished = 1;
			while ($finished and $finished ne 'import') {
				last if (!defined $generator);
				print BOLD YELLOW "\n     /\\\n";
				print        "     \n", RESET;
				print BOLD "Item:\t$generator\n", RESET;
				print " - Type:\t",$typeof{$generator}, "\n";
				print " - Action:\t",$actionof{$generator},"\n";
				print " - Format:\t",$formatof{$generator},"\n";
				#print BLUE "NEXT: ", ${$inputsof{$generator}}[0],"\n",RESET if (defined ${$inputsof{$generator}}[0]);
				$finished = $actionof{$generator};

				$generator = ${$inputsof{$generator}}[0] if (defined ${$inputsof{$generator}}[0]);
			}
		}
	}
}
#if ($opt_view_file) {
#	info("Display: $opt_view_file");
#	print get_file_from_zip($opt_view_file, 1);
#}
exit();

my $yaml = get_file_from_zip('metadata.yaml');
my $metadata_hash_ref = Load($yaml);
my $METADATA_ID = ${$metadata_hash_ref}{'uuid'};
my $TYPE        = ${$metadata_hash_ref}{'type'};
info("Qiime ID: $METADATA_ID");
info("Qiime type: $TYPE");
warning("Encoded Archive_ID differs from file structure.\nDeclared in metadata.yaml: $METADATA_ID\nFound in directory tree: $archive_id")
	if ($METADATA_ID ne $archive_id);


my $provenance_yaml = get_file_from_zip('provenance/metadata.yaml');
my $provenance = Load($provenance_yaml);

print Dumper($provenance);

check_strings('VERSION', "QIIME 2");

sub help {
	print STDERR BOLD GREEN unless ($opt_nocolor);
	print STDERR " === Qiime2 Artifact Metadata Inspector ===\n\n", RESET;
	print STDERR YELLOW unless ($opt_nocolor);
	print STDERR " Url: http://seq.space/telatin/doku.php?id=qzx-view.pl\n\n", RESET;
	print STDERR GREEN unless ($opt_nocolor);
	print STDERR " SYNTAX:\n", RESET;
	print STDERR " view-q2.pl [options] archive.qz?\n\n";

	print STDERR GREEN unless ($opt_nocolor);
	print STDERR " OPTIONS:\n", RESET;
	print STDERR "

 -l, --list [STRING]
 			List all files in the archive. If a string
 			is supplied will 'grep' matching path

 -v, --view STRING
 			View a specific file (path excluding ID)
 			Can be used with --head and --grep

 -g, --grep STRING
 			Print only matching lines (used with --view)

 -j, --head INT
 			Print only the first INT lines (used with --view)

 -s, --spaces INT 
 			Maximum spaces at the begin of the line to print
 			(with --view)

 --shownum
 			Print line number and its lengthnear the output
 			(with --view)

 -d, --debug
 			Enable verbose output and debug info

 -n, --nocolor
 			Disable color output
";
exit;
}

sub check_strings {
	my ($internal_file_name, @strings) = @_;
	my $file_content = get_file_from_zip($internal_file_name, 1);
	foreach my $string (@strings) {
		if ($file_content =~/$string/) {
			info("OK: $string") if ($opt_debug);
		} else {
			warning("Not found \"$string\" in $archive_id::$internal_file_name");
		}
	}
}
sub crash {
	my ($error_message, $error_title, $error_code) = @_;
	$error_title = 'UNDOCUMENTED' unless ($error_title);
	$error_code = 0 unless ($error_code);
	print STDERR BOLD RED unless ($opt_nocolor);
	print STDERR " == ERROR: $error_title ==\n";
	print STDERR RESET unless ($opt_nocolor);
	print STDERR " $error_message\n\n";

	
	exit $error_code if $error_code;
}

sub warning {
	my ($error_message, $error_title, $error_code) = @_;
	$error_title = 'UNDOCUMENTED' unless ($error_title);
	$error_code = 0 unless ($error_code);
	print STDERR BOLD YELLOW unless ($opt_nocolor);
	print STDERR " == WARNING: $error_title ==\n";
	print STDERR RESET unless ($opt_nocolor);
	print STDERR " $error_message\n\n";	
}

sub info {
	my ($error_message) = @_;
	my ($key, $val) = split /:\s+/, $error_message;
	print STDERR  GREEN unless ($opt_nocolor);
	print STDERR "  = ";
	if ($val) {
		print STDERR $key, ":\t", RESET, $val,"\n";
	} else {
		print STDERR RESET, " $key\n";	
	}

}

sub cmd {
	my ($command, $title) = @_;
	$title = '<PrivateCommand>' unless ($title);
	if ($opt_debug) {
		print STDERR "\n" if ($opt_debug);
		print STDERR BOLD GREEN unless ($opt_nocolor);
		print STDERR "  = Running: $title\n", RESET;
		print STDERR "    `$command`\n";
	}
	my $output_strings = `$command`;

	if ($?) {
		crash("$title error", "Command:\n$command\nExit code: $?\n", $?);
	}
	info("Program finished") if ($opt_debug and !$?);
	return $output_strings;


}

sub testzip {
	my $test_string = 'UnZip 6.00 of 20 April 2009';
	my $test_command = 'unzip -v';
	my $output = cmd($test_command, 'Testing unzip binary');
	if ($output!~/$test_string/) {
		print STDERR YELLOW unless ($opt_nocolor);
		print " = WARNING =\n", RESET;
		print " Script tested using \"!$test_string\"."
	} else {
		if ($opt_debug) {
			info("OK: unzip command found.");
		}
	}
}

sub parse_zip_files {
	my $archive_name = shift(@_);
	my $unzip_command = qq(unzip -t \"$archive_name\");
	my $unzip_string  = cmd($unzip_command, 'Inspecting ZIP file content');
	my @lines = split /\n/, $unzip_string;
	my $archive_id;
	my $prev_archive_id;
	my @files;
	foreach my $line (@lines) {
		if ($line =~/testing:\s+([^\/]+)\/(\S+)\s+OK/) {
			$archive_id = $1;
			my $filename = $2;

			if ($opt_debug) {
				print STDERR GREEN unless ($opt_nocolor);
				print STDERR "  - ", RESET, "$filename\n";
			}

			
			if ($prev_archive_id and $prev_archive_id ne $archive_id) {
				warning('Unexpected archive content: '."$prev_archive_id <> $archive_id");
			}
			$prev_archive_id = $archive_id;
			push(@files, $filename);

		}
	}
	return ($archive_id, \@files);
}

sub get_file_from_zip {
	my $file = shift(@_);
	my $silent_always = shift(@_);
	my $cat_command = qq(unzip -p \"$filename\" \"$archive_id/$file\");
	my $output = cmd($cat_command, "Inspect file ($file)");
	info("Parsing: $file") if ($opt_debug and !$silent_always);
	print STDERR $output if ($opt_debug);
	return $output;
}
